// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_vm

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func VmResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"constraints": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"additional_resources": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"storage": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"megabytes": schema.Int64Attribute{
											Required: true,
										},
										"type": schema.StringAttribute{
											Required: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"HDD",
													"SSD",
													"NVMe",
												),
											},
										},
									},
									CustomType: StorageType{
										ObjectType: types.ObjectType{
											AttrTypes: StorageValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
							},
						},
						CustomType: AdditionalResourcesType{
							ObjectType: types.ObjectType{
								AttrTypes: AdditionalResourcesValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"basic_configuration": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"datacenter": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"countries": schema.ListAttribute{
								ElementType: types.StringType,
								Required:    true,
								Validators: []validator.List{
									listvalidator.UniqueValues(),
								},
							},
						},
						CustomType: DatacenterType{
							ObjectType: types.ObjectType{
								AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"hardware": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"cpu": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"architecture": schema.StringAttribute{
											Required: true,
										},
										"manufacturer": schema.StringAttribute{
											Required: true,
										},
									},
									CustomType: CpuType{
										ObjectType: types.ObjectType{
											AttrTypes: CpuValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
								Validators: []validator.List{
									listvalidator.UniqueValues(),
								},
							},
							"memory": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"generation": schema.StringAttribute{
											Required: true,
										},
										"type": schema.StringAttribute{
											Required: true,
										},
									},
									CustomType: MemoryType{
										ObjectType: types.ObjectType{
											AttrTypes: MemoryValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
								Validators: []validator.List{
									listvalidator.UniqueValues(),
								},
							},
							"storage": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"type": schema.StringAttribute{
											Required: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"HDD",
													"SSD",
													"NVMe",
												),
											},
										},
									},
									CustomType: StorageType{
										ObjectType: types.ObjectType{
											AttrTypes: StorageValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
								Validators: []validator.List{
									listvalidator.UniqueValues(),
								},
							},
						},
						CustomType: HardwareType{
							ObjectType: types.ObjectType{
								AttrTypes: HardwareValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"max_total_price_per_epoch_usd": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: ConstraintsType{
					ObjectType: types.ObjectType{
						AttrTypes: ConstraintsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"instances": schema.Int64Attribute{
				Required: true,
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
			"vm_configuration": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Required: true,
					},
					"open_ports": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									Required: true,
									Validators: []validator.Int64{
										int64validator.AtLeast(0),
									},
								},
								"protocol": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"tcp",
											"udp",
											"sctp",
										),
									},
								},
							},
							CustomType: OpenPortsType{
								ObjectType: types.ObjectType{
									AttrTypes: OpenPortsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Required: true,
					},
					"os_image": schema.StringAttribute{
						Required: true,
					},
					"ssh_keys": schema.ListAttribute{
						ElementType: types.StringType,
						Required:    true,
					},
				},
				CustomType: VmConfigurationType{
					ObjectType: types.ObjectType{
						AttrTypes: VmConfigurationValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
		},
	}
}

type VmModel struct {
	Constraints     ConstraintsValue     `tfsdk:"constraints"`
	Instances       types.Int64          `tfsdk:"instances"`
	VmConfiguration VmConfigurationValue `tfsdk:"vm_configuration"`
}

var _ basetypes.ObjectTypable = ConstraintsType{}

type ConstraintsType struct {
	basetypes.ObjectType
}

func (t ConstraintsType) Equal(o attr.Type) bool {
	other, ok := o.(ConstraintsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConstraintsType) String() string {
	return "ConstraintsType"
}

func (t ConstraintsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalResourcesAttribute, ok := attributes["additional_resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_resources is missing from object`)

		return nil, diags
	}

	additionalResourcesVal, ok := additionalResourcesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_resources expected to be basetypes.ObjectValue, was: %T`, additionalResourcesAttribute))
	}

	basicConfigurationAttribute, ok := attributes["basic_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`basic_configuration is missing from object`)

		return nil, diags
	}

	basicConfigurationVal, ok := basicConfigurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`basic_configuration expected to be basetypes.StringValue, was: %T`, basicConfigurationAttribute))
	}

	datacenterAttribute, ok := attributes["datacenter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datacenter is missing from object`)

		return nil, diags
	}

	datacenterVal, ok := datacenterAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datacenter expected to be basetypes.ObjectValue, was: %T`, datacenterAttribute))
	}

	hardwareAttribute, ok := attributes["hardware"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hardware is missing from object`)

		return nil, diags
	}

	hardwareVal, ok := hardwareAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hardware expected to be basetypes.ObjectValue, was: %T`, hardwareAttribute))
	}

	maxTotalPricePerEpochUsdAttribute, ok := attributes["max_total_price_per_epoch_usd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_total_price_per_epoch_usd is missing from object`)

		return nil, diags
	}

	maxTotalPricePerEpochUsdVal, ok := maxTotalPricePerEpochUsdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_total_price_per_epoch_usd expected to be basetypes.StringValue, was: %T`, maxTotalPricePerEpochUsdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConstraintsValue{
		AdditionalResources:      additionalResourcesVal,
		BasicConfiguration:       basicConfigurationVal,
		Datacenter:               datacenterVal,
		Hardware:                 hardwareVal,
		MaxTotalPricePerEpochUsd: maxTotalPricePerEpochUsdVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewConstraintsValueNull() ConstraintsValue {
	return ConstraintsValue{
		state: attr.ValueStateNull,
	}
}

func NewConstraintsValueUnknown() ConstraintsValue {
	return ConstraintsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConstraintsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConstraintsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConstraintsValue Attribute Value",
				"While creating a ConstraintsValue value, a missing attribute value was detected. "+
					"A ConstraintsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConstraintsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConstraintsValue Attribute Type",
				"While creating a ConstraintsValue value, an invalid attribute value was detected. "+
					"A ConstraintsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConstraintsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConstraintsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConstraintsValue Attribute Value",
				"While creating a ConstraintsValue value, an extra attribute value was detected. "+
					"A ConstraintsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConstraintsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConstraintsValueUnknown(), diags
	}

	additionalResourcesAttribute, ok := attributes["additional_resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_resources is missing from object`)

		return NewConstraintsValueUnknown(), diags
	}

	additionalResourcesVal, ok := additionalResourcesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_resources expected to be basetypes.ObjectValue, was: %T`, additionalResourcesAttribute))
	}

	basicConfigurationAttribute, ok := attributes["basic_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`basic_configuration is missing from object`)

		return NewConstraintsValueUnknown(), diags
	}

	basicConfigurationVal, ok := basicConfigurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`basic_configuration expected to be basetypes.StringValue, was: %T`, basicConfigurationAttribute))
	}

	datacenterAttribute, ok := attributes["datacenter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datacenter is missing from object`)

		return NewConstraintsValueUnknown(), diags
	}

	datacenterVal, ok := datacenterAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datacenter expected to be basetypes.ObjectValue, was: %T`, datacenterAttribute))
	}

	hardwareAttribute, ok := attributes["hardware"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hardware is missing from object`)

		return NewConstraintsValueUnknown(), diags
	}

	hardwareVal, ok := hardwareAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hardware expected to be basetypes.ObjectValue, was: %T`, hardwareAttribute))
	}

	maxTotalPricePerEpochUsdAttribute, ok := attributes["max_total_price_per_epoch_usd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_total_price_per_epoch_usd is missing from object`)

		return NewConstraintsValueUnknown(), diags
	}

	maxTotalPricePerEpochUsdVal, ok := maxTotalPricePerEpochUsdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_total_price_per_epoch_usd expected to be basetypes.StringValue, was: %T`, maxTotalPricePerEpochUsdAttribute))
	}

	if diags.HasError() {
		return NewConstraintsValueUnknown(), diags
	}

	return ConstraintsValue{
		AdditionalResources:      additionalResourcesVal,
		BasicConfiguration:       basicConfigurationVal,
		Datacenter:               datacenterVal,
		Hardware:                 hardwareVal,
		MaxTotalPricePerEpochUsd: maxTotalPricePerEpochUsdVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewConstraintsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConstraintsValue {
	object, diags := NewConstraintsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConstraintsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConstraintsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConstraintsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConstraintsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConstraintsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConstraintsValueMust(ConstraintsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConstraintsType) ValueType(ctx context.Context) attr.Value {
	return ConstraintsValue{}
}

var _ basetypes.ObjectValuable = ConstraintsValue{}

type ConstraintsValue struct {
	AdditionalResources      basetypes.ObjectValue `tfsdk:"additional_resources"`
	BasicConfiguration       basetypes.StringValue `tfsdk:"basic_configuration"`
	Datacenter               basetypes.ObjectValue `tfsdk:"datacenter"`
	Hardware                 basetypes.ObjectValue `tfsdk:"hardware"`
	MaxTotalPricePerEpochUsd basetypes.StringValue `tfsdk:"max_total_price_per_epoch_usd"`
	state                    attr.ValueState
}

func (v ConstraintsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["additional_resources"] = basetypes.ObjectType{
		AttrTypes: AdditionalResourcesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["basic_configuration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["datacenter"] = basetypes.ObjectType{
		AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["hardware"] = basetypes.ObjectType{
		AttrTypes: HardwareValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["max_total_price_per_epoch_usd"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AdditionalResources.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_resources"] = val

		val, err = v.BasicConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["basic_configuration"] = val

		val, err = v.Datacenter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datacenter"] = val

		val, err = v.Hardware.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hardware"] = val

		val, err = v.MaxTotalPricePerEpochUsd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_total_price_per_epoch_usd"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConstraintsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConstraintsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConstraintsValue) String() string {
	return "ConstraintsValue"
}

func (v ConstraintsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var additionalResources basetypes.ObjectValue

	if v.AdditionalResources.IsNull() {
		additionalResources = types.ObjectNull(
			AdditionalResourcesValue{}.AttributeTypes(ctx),
		)
	}

	if v.AdditionalResources.IsUnknown() {
		additionalResources = types.ObjectUnknown(
			AdditionalResourcesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AdditionalResources.IsNull() && !v.AdditionalResources.IsUnknown() {
		additionalResources = types.ObjectValueMust(
			AdditionalResourcesValue{}.AttributeTypes(ctx),
			v.AdditionalResources.Attributes(),
		)
	}

	var datacenter basetypes.ObjectValue

	if v.Datacenter.IsNull() {
		datacenter = types.ObjectNull(
			DatacenterValue{}.AttributeTypes(ctx),
		)
	}

	if v.Datacenter.IsUnknown() {
		datacenter = types.ObjectUnknown(
			DatacenterValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Datacenter.IsNull() && !v.Datacenter.IsUnknown() {
		datacenter = types.ObjectValueMust(
			DatacenterValue{}.AttributeTypes(ctx),
			v.Datacenter.Attributes(),
		)
	}

	var hardware basetypes.ObjectValue

	if v.Hardware.IsNull() {
		hardware = types.ObjectNull(
			HardwareValue{}.AttributeTypes(ctx),
		)
	}

	if v.Hardware.IsUnknown() {
		hardware = types.ObjectUnknown(
			HardwareValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Hardware.IsNull() && !v.Hardware.IsUnknown() {
		hardware = types.ObjectValueMust(
			HardwareValue{}.AttributeTypes(ctx),
			v.Hardware.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"additional_resources": basetypes.ObjectType{
			AttrTypes: AdditionalResourcesValue{}.AttributeTypes(ctx),
		},
		"basic_configuration": basetypes.StringType{},
		"datacenter": basetypes.ObjectType{
			AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
		},
		"hardware": basetypes.ObjectType{
			AttrTypes: HardwareValue{}.AttributeTypes(ctx),
		},
		"max_total_price_per_epoch_usd": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_resources":          additionalResources,
			"basic_configuration":           v.BasicConfiguration,
			"datacenter":                    datacenter,
			"hardware":                      hardware,
			"max_total_price_per_epoch_usd": v.MaxTotalPricePerEpochUsd,
		})

	return objVal, diags
}

func (v ConstraintsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConstraintsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalResources.Equal(other.AdditionalResources) {
		return false
	}

	if !v.BasicConfiguration.Equal(other.BasicConfiguration) {
		return false
	}

	if !v.Datacenter.Equal(other.Datacenter) {
		return false
	}

	if !v.Hardware.Equal(other.Hardware) {
		return false
	}

	if !v.MaxTotalPricePerEpochUsd.Equal(other.MaxTotalPricePerEpochUsd) {
		return false
	}

	return true
}

func (v ConstraintsValue) Type(ctx context.Context) attr.Type {
	return ConstraintsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConstraintsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_resources": basetypes.ObjectType{
			AttrTypes: AdditionalResourcesValue{}.AttributeTypes(ctx),
		},
		"basic_configuration": basetypes.StringType{},
		"datacenter": basetypes.ObjectType{
			AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
		},
		"hardware": basetypes.ObjectType{
			AttrTypes: HardwareValue{}.AttributeTypes(ctx),
		},
		"max_total_price_per_epoch_usd": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AdditionalResourcesType{}

type AdditionalResourcesType struct {
	basetypes.ObjectType
}

func (t AdditionalResourcesType) Equal(o attr.Type) bool {
	other, ok := o.(AdditionalResourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AdditionalResourcesType) String() string {
	return "AdditionalResourcesType"
}

func (t AdditionalResourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.ListValue, was: %T`, storageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AdditionalResourcesValue{
		Storage: storageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAdditionalResourcesValueNull() AdditionalResourcesValue {
	return AdditionalResourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewAdditionalResourcesValueUnknown() AdditionalResourcesValue {
	return AdditionalResourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAdditionalResourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AdditionalResourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AdditionalResourcesValue Attribute Value",
				"While creating a AdditionalResourcesValue value, a missing attribute value was detected. "+
					"A AdditionalResourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdditionalResourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AdditionalResourcesValue Attribute Type",
				"While creating a AdditionalResourcesValue value, an invalid attribute value was detected. "+
					"A AdditionalResourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdditionalResourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AdditionalResourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AdditionalResourcesValue Attribute Value",
				"While creating a AdditionalResourcesValue value, an extra attribute value was detected. "+
					"A AdditionalResourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AdditionalResourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAdditionalResourcesValueUnknown(), diags
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewAdditionalResourcesValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.ListValue, was: %T`, storageAttribute))
	}

	if diags.HasError() {
		return NewAdditionalResourcesValueUnknown(), diags
	}

	return AdditionalResourcesValue{
		Storage: storageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAdditionalResourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AdditionalResourcesValue {
	object, diags := NewAdditionalResourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAdditionalResourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AdditionalResourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAdditionalResourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAdditionalResourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAdditionalResourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAdditionalResourcesValueMust(AdditionalResourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AdditionalResourcesType) ValueType(ctx context.Context) attr.Value {
	return AdditionalResourcesValue{}
}

var _ basetypes.ObjectValuable = AdditionalResourcesValue{}

type AdditionalResourcesValue struct {
	Storage basetypes.ListValue `tfsdk:"storage"`
	state   attr.ValueState
}

func (v AdditionalResourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["storage"] = basetypes.ListType{
		ElemType: StorageValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AdditionalResourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AdditionalResourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AdditionalResourcesValue) String() string {
	return "AdditionalResourcesValue"
}

func (v AdditionalResourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	storage := types.ListValueMust(
		StorageType{
			basetypes.ObjectType{
				AttrTypes: StorageValue{}.AttributeTypes(ctx),
			},
		},
		v.Storage.Elements(),
	)

	if v.Storage.IsNull() {
		storage = types.ListNull(
			StorageType{
				basetypes.ObjectType{
					AttrTypes: StorageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Storage.IsUnknown() {
		storage = types.ListUnknown(
			StorageType{
				basetypes.ObjectType{
					AttrTypes: StorageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"storage": basetypes.ListType{
			ElemType: StorageValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"storage": storage,
		})

	return objVal, diags
}

func (v AdditionalResourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(AdditionalResourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	return true
}

func (v AdditionalResourcesValue) Type(ctx context.Context) attr.Type {
	return AdditionalResourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AdditionalResourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"storage": basetypes.ListType{
			ElemType: StorageValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DatacenterType{}

type DatacenterType struct {
	basetypes.ObjectType
}

func (t DatacenterType) Equal(o attr.Type) bool {
	other, ok := o.(DatacenterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DatacenterType) String() string {
	return "DatacenterType"
}

func (t DatacenterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countriesAttribute, ok := attributes["countries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`countries is missing from object`)

		return nil, diags
	}

	countriesVal, ok := countriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`countries expected to be basetypes.ListValue, was: %T`, countriesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DatacenterValue{
		Countries: countriesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDatacenterValueNull() DatacenterValue {
	return DatacenterValue{
		state: attr.ValueStateNull,
	}
}

func NewDatacenterValueUnknown() DatacenterValue {
	return DatacenterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDatacenterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DatacenterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DatacenterValue Attribute Value",
				"While creating a DatacenterValue value, a missing attribute value was detected. "+
					"A DatacenterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatacenterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DatacenterValue Attribute Type",
				"While creating a DatacenterValue value, an invalid attribute value was detected. "+
					"A DatacenterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatacenterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DatacenterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DatacenterValue Attribute Value",
				"While creating a DatacenterValue value, an extra attribute value was detected. "+
					"A DatacenterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DatacenterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDatacenterValueUnknown(), diags
	}

	countriesAttribute, ok := attributes["countries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`countries is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	countriesVal, ok := countriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`countries expected to be basetypes.ListValue, was: %T`, countriesAttribute))
	}

	if diags.HasError() {
		return NewDatacenterValueUnknown(), diags
	}

	return DatacenterValue{
		Countries: countriesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDatacenterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DatacenterValue {
	object, diags := NewDatacenterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDatacenterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DatacenterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDatacenterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDatacenterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDatacenterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDatacenterValueMust(DatacenterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DatacenterType) ValueType(ctx context.Context) attr.Value {
	return DatacenterValue{}
}

var _ basetypes.ObjectValuable = DatacenterValue{}

type DatacenterValue struct {
	Countries basetypes.ListValue `tfsdk:"countries"`
	state     attr.ValueState
}

func (v DatacenterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["countries"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Countries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["countries"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DatacenterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DatacenterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DatacenterValue) String() string {
	return "DatacenterValue"
}

func (v DatacenterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var countriesVal basetypes.ListValue
	switch {
	case v.Countries.IsUnknown():
		countriesVal = types.ListUnknown(types.StringType)
	case v.Countries.IsNull():
		countriesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		countriesVal, d = types.ListValue(types.StringType, v.Countries.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"countries": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"countries": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"countries": countriesVal,
		})

	return objVal, diags
}

func (v DatacenterValue) Equal(o attr.Value) bool {
	other, ok := o.(DatacenterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Countries.Equal(other.Countries) {
		return false
	}

	return true
}

func (v DatacenterValue) Type(ctx context.Context) attr.Type {
	return DatacenterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DatacenterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"countries": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = HardwareType{}

type HardwareType struct {
	basetypes.ObjectType
}

func (t HardwareType) Equal(o attr.Type) bool {
	other, ok := o.(HardwareType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HardwareType) String() string {
	return "HardwareType"
}

func (t HardwareType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return nil, diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.ListValue, was: %T`, cpuAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.ListValue, was: %T`, memoryAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.ListValue, was: %T`, storageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HardwareValue{
		Cpu:     cpuVal,
		Memory:  memoryVal,
		Storage: storageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHardwareValueNull() HardwareValue {
	return HardwareValue{
		state: attr.ValueStateNull,
	}
}

func NewHardwareValueUnknown() HardwareValue {
	return HardwareValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHardwareValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HardwareValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HardwareValue Attribute Value",
				"While creating a HardwareValue value, a missing attribute value was detected. "+
					"A HardwareValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HardwareValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HardwareValue Attribute Type",
				"While creating a HardwareValue value, an invalid attribute value was detected. "+
					"A HardwareValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HardwareValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HardwareValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HardwareValue Attribute Value",
				"While creating a HardwareValue value, an extra attribute value was detected. "+
					"A HardwareValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HardwareValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHardwareValueUnknown(), diags
	}

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return NewHardwareValueUnknown(), diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.ListValue, was: %T`, cpuAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewHardwareValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.ListValue, was: %T`, memoryAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewHardwareValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.ListValue, was: %T`, storageAttribute))
	}

	if diags.HasError() {
		return NewHardwareValueUnknown(), diags
	}

	return HardwareValue{
		Cpu:     cpuVal,
		Memory:  memoryVal,
		Storage: storageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHardwareValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HardwareValue {
	object, diags := NewHardwareValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHardwareValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HardwareType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHardwareValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHardwareValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHardwareValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHardwareValueMust(HardwareValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HardwareType) ValueType(ctx context.Context) attr.Value {
	return HardwareValue{}
}

var _ basetypes.ObjectValuable = HardwareValue{}

type HardwareValue struct {
	Cpu     basetypes.ListValue `tfsdk:"cpu"`
	Memory  basetypes.ListValue `tfsdk:"memory"`
	Storage basetypes.ListValue `tfsdk:"storage"`
	state   attr.ValueState
}

func (v HardwareValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["cpu"] = basetypes.ListType{
		ElemType: CpuValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.ListType{
		ElemType: MemoryValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["storage"] = basetypes.ListType{
		ElemType: StorageValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Cpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HardwareValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HardwareValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HardwareValue) String() string {
	return "HardwareValue"
}

func (v HardwareValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	cpu := types.ListValueMust(
		CpuType{
			basetypes.ObjectType{
				AttrTypes: CpuValue{}.AttributeTypes(ctx),
			},
		},
		v.Cpu.Elements(),
	)

	if v.Cpu.IsNull() {
		cpu = types.ListNull(
			CpuType{
				basetypes.ObjectType{
					AttrTypes: CpuValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Cpu.IsUnknown() {
		cpu = types.ListUnknown(
			CpuType{
				basetypes.ObjectType{
					AttrTypes: CpuValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	memory := types.ListValueMust(
		MemoryType{
			basetypes.ObjectType{
				AttrTypes: MemoryValue{}.AttributeTypes(ctx),
			},
		},
		v.Memory.Elements(),
	)

	if v.Memory.IsNull() {
		memory = types.ListNull(
			MemoryType{
				basetypes.ObjectType{
					AttrTypes: MemoryValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Memory.IsUnknown() {
		memory = types.ListUnknown(
			MemoryType{
				basetypes.ObjectType{
					AttrTypes: MemoryValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	storage := types.ListValueMust(
		StorageType{
			basetypes.ObjectType{
				AttrTypes: StorageValue{}.AttributeTypes(ctx),
			},
		},
		v.Storage.Elements(),
	)

	if v.Storage.IsNull() {
		storage = types.ListNull(
			StorageType{
				basetypes.ObjectType{
					AttrTypes: StorageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Storage.IsUnknown() {
		storage = types.ListUnknown(
			StorageType{
				basetypes.ObjectType{
					AttrTypes: StorageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"cpu": basetypes.ListType{
			ElemType: CpuValue{}.Type(ctx),
		},
		"memory": basetypes.ListType{
			ElemType: MemoryValue{}.Type(ctx),
		},
		"storage": basetypes.ListType{
			ElemType: StorageValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu":     cpu,
			"memory":  memory,
			"storage": storage,
		})

	return objVal, diags
}

func (v HardwareValue) Equal(o attr.Value) bool {
	other, ok := o.(HardwareValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cpu.Equal(other.Cpu) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	return true
}

func (v HardwareValue) Type(ctx context.Context) attr.Type {
	return HardwareType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HardwareValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu": basetypes.ListType{
			ElemType: CpuValue{}.Type(ctx),
		},
		"memory": basetypes.ListType{
			ElemType: MemoryValue{}.Type(ctx),
		},
		"storage": basetypes.ListType{
			ElemType: StorageValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CpuType{}

type CpuType struct {
	basetypes.ObjectType
}

func (t CpuType) Equal(o attr.Type) bool {
	other, ok := o.(CpuType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CpuType) String() string {
	return "CpuType"
}

func (t CpuType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	architectureAttribute, ok := attributes["architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`architecture is missing from object`)

		return nil, diags
	}

	architectureVal, ok := architectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`architecture expected to be basetypes.StringValue, was: %T`, architectureAttribute))
	}

	manufacturerAttribute, ok := attributes["manufacturer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manufacturer is missing from object`)

		return nil, diags
	}

	manufacturerVal, ok := manufacturerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manufacturer expected to be basetypes.StringValue, was: %T`, manufacturerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CpuValue{
		Architecture: architectureVal,
		Manufacturer: manufacturerVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCpuValueNull() CpuValue {
	return CpuValue{
		state: attr.ValueStateNull,
	}
}

func NewCpuValueUnknown() CpuValue {
	return CpuValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCpuValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CpuValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CpuValue Attribute Value",
				"While creating a CpuValue value, a missing attribute value was detected. "+
					"A CpuValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CpuValue Attribute Type",
				"While creating a CpuValue value, an invalid attribute value was detected. "+
					"A CpuValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CpuValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CpuValue Attribute Value",
				"While creating a CpuValue value, an extra attribute value was detected. "+
					"A CpuValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CpuValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCpuValueUnknown(), diags
	}

	architectureAttribute, ok := attributes["architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`architecture is missing from object`)

		return NewCpuValueUnknown(), diags
	}

	architectureVal, ok := architectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`architecture expected to be basetypes.StringValue, was: %T`, architectureAttribute))
	}

	manufacturerAttribute, ok := attributes["manufacturer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manufacturer is missing from object`)

		return NewCpuValueUnknown(), diags
	}

	manufacturerVal, ok := manufacturerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manufacturer expected to be basetypes.StringValue, was: %T`, manufacturerAttribute))
	}

	if diags.HasError() {
		return NewCpuValueUnknown(), diags
	}

	return CpuValue{
		Architecture: architectureVal,
		Manufacturer: manufacturerVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCpuValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CpuValue {
	object, diags := NewCpuValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCpuValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CpuType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCpuValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCpuValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCpuValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCpuValueMust(CpuValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CpuType) ValueType(ctx context.Context) attr.Value {
	return CpuValue{}
}

var _ basetypes.ObjectValuable = CpuValue{}

type CpuValue struct {
	Architecture basetypes.StringValue `tfsdk:"architecture"`
	Manufacturer basetypes.StringValue `tfsdk:"manufacturer"`
	state        attr.ValueState
}

func (v CpuValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["architecture"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["manufacturer"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Architecture.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["architecture"] = val

		val, err = v.Manufacturer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manufacturer"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CpuValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CpuValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CpuValue) String() string {
	return "CpuValue"
}

func (v CpuValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"architecture": basetypes.StringType{},
		"manufacturer": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"architecture": v.Architecture,
			"manufacturer": v.Manufacturer,
		})

	return objVal, diags
}

func (v CpuValue) Equal(o attr.Value) bool {
	other, ok := o.(CpuValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Architecture.Equal(other.Architecture) {
		return false
	}

	if !v.Manufacturer.Equal(other.Manufacturer) {
		return false
	}

	return true
}

func (v CpuValue) Type(ctx context.Context) attr.Type {
	return CpuType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CpuValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"architecture": basetypes.StringType{},
		"manufacturer": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MemoryType{}

type MemoryType struct {
	basetypes.ObjectType
}

func (t MemoryType) Equal(o attr.Type) bool {
	other, ok := o.(MemoryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MemoryType) String() string {
	return "MemoryType"
}

func (t MemoryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	generationAttribute, ok := attributes["generation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`generation is missing from object`)

		return nil, diags
	}

	generationVal, ok := generationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`generation expected to be basetypes.StringValue, was: %T`, generationAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MemoryValue{
		Generation: generationVal,
		MemoryType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMemoryValueNull() MemoryValue {
	return MemoryValue{
		state: attr.ValueStateNull,
	}
}

func NewMemoryValueUnknown() MemoryValue {
	return MemoryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMemoryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MemoryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MemoryValue Attribute Value",
				"While creating a MemoryValue value, a missing attribute value was detected. "+
					"A MemoryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MemoryValue Attribute Type",
				"While creating a MemoryValue value, an invalid attribute value was detected. "+
					"A MemoryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MemoryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MemoryValue Attribute Value",
				"While creating a MemoryValue value, an extra attribute value was detected. "+
					"A MemoryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MemoryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMemoryValueUnknown(), diags
	}

	generationAttribute, ok := attributes["generation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`generation is missing from object`)

		return NewMemoryValueUnknown(), diags
	}

	generationVal, ok := generationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`generation expected to be basetypes.StringValue, was: %T`, generationAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewMemoryValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewMemoryValueUnknown(), diags
	}

	return MemoryValue{
		Generation: generationVal,
		MemoryType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMemoryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MemoryValue {
	object, diags := NewMemoryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMemoryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MemoryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMemoryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMemoryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMemoryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMemoryValueMust(MemoryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MemoryType) ValueType(ctx context.Context) attr.Value {
	return MemoryValue{}
}

var _ basetypes.ObjectValuable = MemoryValue{}

type MemoryValue struct {
	Generation basetypes.StringValue `tfsdk:"generation"`
	MemoryType basetypes.StringValue `tfsdk:"type"`
	state      attr.ValueState
}

func (v MemoryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["generation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Generation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["generation"] = val

		val, err = v.MemoryType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MemoryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MemoryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MemoryValue) String() string {
	return "MemoryValue"
}

func (v MemoryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"generation": basetypes.StringType{},
		"type":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"generation": v.Generation,
			"type":       v.MemoryType,
		})

	return objVal, diags
}

func (v MemoryValue) Equal(o attr.Value) bool {
	other, ok := o.(MemoryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Generation.Equal(other.Generation) {
		return false
	}

	if !v.MemoryType.Equal(other.MemoryType) {
		return false
	}

	return true
}

func (v MemoryValue) Type(ctx context.Context) attr.Type {
	return MemoryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MemoryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"generation": basetypes.StringType{},
		"type":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StorageType{}

type StorageType struct {
	basetypes.ObjectType
}

func (t StorageType) Equal(o attr.Type) bool {
	other, ok := o.(StorageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StorageType) String() string {
	return "StorageType"
}

func (t StorageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StorageValue{
		StorageType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStorageValueNull() StorageValue {
	return StorageValue{
		state: attr.ValueStateNull,
	}
}

func NewStorageValueUnknown() StorageValue {
	return StorageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStorageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StorageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StorageValue Attribute Value",
				"While creating a StorageValue value, a missing attribute value was detected. "+
					"A StorageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StorageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StorageValue Attribute Type",
				"While creating a StorageValue value, an invalid attribute value was detected. "+
					"A StorageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StorageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StorageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StorageValue Attribute Value",
				"While creating a StorageValue value, an extra attribute value was detected. "+
					"A StorageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StorageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStorageValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewStorageValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewStorageValueUnknown(), diags
	}

	return StorageValue{
		StorageType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStorageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StorageValue {
	object, diags := NewStorageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStorageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StorageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStorageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStorageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStorageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStorageValueMust(StorageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StorageType) ValueType(ctx context.Context) attr.Value {
	return StorageValue{}
}

var _ basetypes.ObjectValuable = StorageValue{}

type StorageValue struct {
	StorageType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v StorageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.StorageType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StorageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StorageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StorageValue) String() string {
	return "StorageValue"
}

func (v StorageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type": v.StorageType,
		})

	return objVal, diags
}

func (v StorageValue) Equal(o attr.Value) bool {
	other, ok := o.(StorageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.StorageType.Equal(other.StorageType) {
		return false
	}

	return true
}

func (v StorageValue) Type(ctx context.Context) attr.Type {
	return StorageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StorageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VmConfigurationType{}

type VmConfigurationType struct {
	basetypes.ObjectType
}

func (t VmConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(VmConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VmConfigurationType) String() string {
	return "VmConfigurationType"
}

func (t VmConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	openPortsAttribute, ok := attributes["open_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`open_ports is missing from object`)

		return nil, diags
	}

	openPortsVal, ok := openPortsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`open_ports expected to be basetypes.ListValue, was: %T`, openPortsAttribute))
	}

	osImageAttribute, ok := attributes["os_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os_image is missing from object`)

		return nil, diags
	}

	osImageVal, ok := osImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os_image expected to be basetypes.StringValue, was: %T`, osImageAttribute))
	}

	sshKeysAttribute, ok := attributes["ssh_keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_keys is missing from object`)

		return nil, diags
	}

	sshKeysVal, ok := sshKeysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_keys expected to be basetypes.ListValue, was: %T`, sshKeysAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VmConfigurationValue{
		Name:      nameVal,
		OpenPorts: openPortsVal,
		OsImage:   osImageVal,
		SshKeys:   sshKeysVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVmConfigurationValueNull() VmConfigurationValue {
	return VmConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewVmConfigurationValueUnknown() VmConfigurationValue {
	return VmConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVmConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VmConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VmConfigurationValue Attribute Value",
				"While creating a VmConfigurationValue value, a missing attribute value was detected. "+
					"A VmConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VmConfigurationValue Attribute Type",
				"While creating a VmConfigurationValue value, an invalid attribute value was detected. "+
					"A VmConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VmConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VmConfigurationValue Attribute Value",
				"While creating a VmConfigurationValue value, an extra attribute value was detected. "+
					"A VmConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VmConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVmConfigurationValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVmConfigurationValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	openPortsAttribute, ok := attributes["open_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`open_ports is missing from object`)

		return NewVmConfigurationValueUnknown(), diags
	}

	openPortsVal, ok := openPortsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`open_ports expected to be basetypes.ListValue, was: %T`, openPortsAttribute))
	}

	osImageAttribute, ok := attributes["os_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os_image is missing from object`)

		return NewVmConfigurationValueUnknown(), diags
	}

	osImageVal, ok := osImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os_image expected to be basetypes.StringValue, was: %T`, osImageAttribute))
	}

	sshKeysAttribute, ok := attributes["ssh_keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_keys is missing from object`)

		return NewVmConfigurationValueUnknown(), diags
	}

	sshKeysVal, ok := sshKeysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_keys expected to be basetypes.ListValue, was: %T`, sshKeysAttribute))
	}

	if diags.HasError() {
		return NewVmConfigurationValueUnknown(), diags
	}

	return VmConfigurationValue{
		Name:      nameVal,
		OpenPorts: openPortsVal,
		OsImage:   osImageVal,
		SshKeys:   sshKeysVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVmConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VmConfigurationValue {
	object, diags := NewVmConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVmConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VmConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVmConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVmConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVmConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVmConfigurationValueMust(VmConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VmConfigurationType) ValueType(ctx context.Context) attr.Value {
	return VmConfigurationValue{}
}

var _ basetypes.ObjectValuable = VmConfigurationValue{}

type VmConfigurationValue struct {
	Name      basetypes.StringValue `tfsdk:"name"`
	OpenPorts basetypes.ListValue   `tfsdk:"open_ports"`
	OsImage   basetypes.StringValue `tfsdk:"os_image"`
	SshKeys   basetypes.ListValue   `tfsdk:"ssh_keys"`
	state     attr.ValueState
}

func (v VmConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["open_ports"] = basetypes.ListType{
		ElemType: OpenPortsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["os_image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssh_keys"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OpenPorts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["open_ports"] = val

		val, err = v.OsImage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["os_image"] = val

		val, err = v.SshKeys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh_keys"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VmConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VmConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VmConfigurationValue) String() string {
	return "VmConfigurationValue"
}

func (v VmConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	openPorts := types.ListValueMust(
		OpenPortsType{
			basetypes.ObjectType{
				AttrTypes: OpenPortsValue{}.AttributeTypes(ctx),
			},
		},
		v.OpenPorts.Elements(),
	)

	if v.OpenPorts.IsNull() {
		openPorts = types.ListNull(
			OpenPortsType{
				basetypes.ObjectType{
					AttrTypes: OpenPortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OpenPorts.IsUnknown() {
		openPorts = types.ListUnknown(
			OpenPortsType{
				basetypes.ObjectType{
					AttrTypes: OpenPortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var sshKeysVal basetypes.ListValue
	switch {
	case v.SshKeys.IsUnknown():
		sshKeysVal = types.ListUnknown(types.StringType)
	case v.SshKeys.IsNull():
		sshKeysVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		sshKeysVal, d = types.ListValue(types.StringType, v.SshKeys.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"name": basetypes.StringType{},
			"open_ports": basetypes.ListType{
				ElemType: OpenPortsValue{}.Type(ctx),
			},
			"os_image": basetypes.StringType{},
			"ssh_keys": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"open_ports": basetypes.ListType{
			ElemType: OpenPortsValue{}.Type(ctx),
		},
		"os_image": basetypes.StringType{},
		"ssh_keys": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":       v.Name,
			"open_ports": openPorts,
			"os_image":   v.OsImage,
			"ssh_keys":   sshKeysVal,
		})

	return objVal, diags
}

func (v VmConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(VmConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OpenPorts.Equal(other.OpenPorts) {
		return false
	}

	if !v.OsImage.Equal(other.OsImage) {
		return false
	}

	if !v.SshKeys.Equal(other.SshKeys) {
		return false
	}

	return true
}

func (v VmConfigurationValue) Type(ctx context.Context) attr.Type {
	return VmConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VmConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"open_ports": basetypes.ListType{
			ElemType: OpenPortsValue{}.Type(ctx),
		},
		"os_image": basetypes.StringType{},
		"ssh_keys": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OpenPortsType{}

type OpenPortsType struct {
	basetypes.ObjectType
}

func (t OpenPortsType) Equal(o attr.Type) bool {
	other, ok := o.(OpenPortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OpenPortsType) String() string {
	return "OpenPortsType"
}

func (t OpenPortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OpenPortsValue{
		Port:     portVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOpenPortsValueNull() OpenPortsValue {
	return OpenPortsValue{
		state: attr.ValueStateNull,
	}
}

func NewOpenPortsValueUnknown() OpenPortsValue {
	return OpenPortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOpenPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OpenPortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OpenPortsValue Attribute Value",
				"While creating a OpenPortsValue value, a missing attribute value was detected. "+
					"A OpenPortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OpenPortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OpenPortsValue Attribute Type",
				"While creating a OpenPortsValue value, an invalid attribute value was detected. "+
					"A OpenPortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OpenPortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OpenPortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OpenPortsValue Attribute Value",
				"While creating a OpenPortsValue value, an extra attribute value was detected. "+
					"A OpenPortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OpenPortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOpenPortsValueUnknown(), diags
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewOpenPortsValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewOpenPortsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewOpenPortsValueUnknown(), diags
	}

	return OpenPortsValue{
		Port:     portVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOpenPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OpenPortsValue {
	object, diags := NewOpenPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOpenPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OpenPortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOpenPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOpenPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOpenPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOpenPortsValueMust(OpenPortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OpenPortsType) ValueType(ctx context.Context) attr.Value {
	return OpenPortsValue{}
}

var _ basetypes.ObjectValuable = OpenPortsValue{}

type OpenPortsValue struct {
	Port     basetypes.Int64Value  `tfsdk:"port"`
	Protocol basetypes.StringValue `tfsdk:"protocol"`
	state    attr.ValueState
}

func (v OpenPortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OpenPortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OpenPortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OpenPortsValue) String() string {
	return "OpenPortsValue"
}

func (v OpenPortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"port":     basetypes.Int64Type{},
		"protocol": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port":     v.Port,
			"protocol": v.Protocol,
		})

	return objVal, diags
}

func (v OpenPortsValue) Equal(o attr.Value) bool {
	other, ok := o.(OpenPortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v OpenPortsValue) Type(ctx context.Context) attr.Type {
	return OpenPortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OpenPortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port":     basetypes.Int64Type{},
		"protocol": basetypes.StringType{},
	}
}
