// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_vm_instances

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func VmInstancesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"vm_instances": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.StringAttribute{
							Computed: true,
						},
						"datacenter": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"certifications": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"city_code": schema.StringAttribute{
									Computed: true,
								},
								"city_index": schema.Int64Attribute{
									Computed: true,
								},
								"country_code": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"tier": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: DatacenterType{
								ObjectType: types.ObjectType{
									AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"next_billing_at": schema.StringAttribute{
							Computed: true,
						},
						"os_image": schema.StringAttribute{
							Computed: true,
						},
						"ports": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"port": schema.Int64Attribute{
										Computed: true,
									},
									"protocol": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PortsType{
									ObjectType: types.ObjectType{
										AttrTypes: PortsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"price_per_epoch": schema.Int64Attribute{
							Computed: true,
						},
						"public_ip": schema.StringAttribute{
							Computed: true,
						},
						"reserved_balance": schema.StringAttribute{
							Computed: true,
						},
						"resources": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"price": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ResourcesType{
									ObjectType: types.ObjectType{
										AttrTypes: ResourcesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed:            true,
							Description:         "```solidity\nenum Status { INSUFFICIENT_FUNDS, ACTIVE, ENDED, NOT_ENOUGH_WORKERS, SMALL_BALANCE }\n```",
							MarkdownDescription: "```solidity\nenum Status { INSUFFICIENT_FUNDS, ACTIVE, ENDED, NOT_ENOUGH_WORKERS, SMALL_BALANCE }\n```",
						},
						"total_spent": schema.StringAttribute{
							Computed: true,
						},
						"vm_name": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: VmInstancesType{
						ObjectType: types.ObjectType{
							AttrTypes: VmInstancesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type VmInstancesModel struct {
	VmInstances types.Set `tfsdk:"vm_instances"`
}

var _ basetypes.ObjectTypable = VmInstancesType{}

type VmInstancesType struct {
	basetypes.ObjectType
}

func (t VmInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VmInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VmInstancesType) String() string {
	return "VmInstancesType"
}

func (t VmInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	datacenterAttribute, ok := attributes["datacenter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datacenter is missing from object`)

		return nil, diags
	}

	datacenterVal, ok := datacenterAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datacenter expected to be basetypes.ObjectValue, was: %T`, datacenterAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nextBillingAtAttribute, ok := attributes["next_billing_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_billing_at is missing from object`)

		return nil, diags
	}

	nextBillingAtVal, ok := nextBillingAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_billing_at expected to be basetypes.StringValue, was: %T`, nextBillingAtAttribute))
	}

	osImageAttribute, ok := attributes["os_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os_image is missing from object`)

		return nil, diags
	}

	osImageVal, ok := osImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os_image expected to be basetypes.StringValue, was: %T`, osImageAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return nil, diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	pricePerEpochAttribute, ok := attributes["price_per_epoch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_per_epoch is missing from object`)

		return nil, diags
	}

	pricePerEpochVal, ok := pricePerEpochAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_per_epoch expected to be basetypes.Int64Value, was: %T`, pricePerEpochAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return nil, diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	reservedBalanceAttribute, ok := attributes["reserved_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_balance is missing from object`)

		return nil, diags
	}

	reservedBalanceVal, ok := reservedBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_balance expected to be basetypes.StringValue, was: %T`, reservedBalanceAttribute))
	}

	resourcesAttribute, ok := attributes["resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources is missing from object`)

		return nil, diags
	}

	resourcesVal, ok := resourcesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources expected to be basetypes.ListValue, was: %T`, resourcesAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	totalSpentAttribute, ok := attributes["total_spent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_spent is missing from object`)

		return nil, diags
	}

	totalSpentVal, ok := totalSpentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_spent expected to be basetypes.StringValue, was: %T`, totalSpentAttribute))
	}

	vmNameAttribute, ok := attributes["vm_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vm_name is missing from object`)

		return nil, diags
	}

	vmNameVal, ok := vmNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vm_name expected to be basetypes.StringValue, was: %T`, vmNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VmInstancesValue{
		CreatedAt:       createdAtVal,
		Datacenter:      datacenterVal,
		Id:              idVal,
		NextBillingAt:   nextBillingAtVal,
		OsImage:         osImageVal,
		Ports:           portsVal,
		PricePerEpoch:   pricePerEpochVal,
		PublicIp:        publicIpVal,
		ReservedBalance: reservedBalanceVal,
		Resources:       resourcesVal,
		Status:          statusVal,
		TotalSpent:      totalSpentVal,
		VmName:          vmNameVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVmInstancesValueNull() VmInstancesValue {
	return VmInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVmInstancesValueUnknown() VmInstancesValue {
	return VmInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVmInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VmInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VmInstancesValue Attribute Value",
				"While creating a VmInstancesValue value, a missing attribute value was detected. "+
					"A VmInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VmInstancesValue Attribute Type",
				"While creating a VmInstancesValue value, an invalid attribute value was detected. "+
					"A VmInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VmInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VmInstancesValue Attribute Value",
				"While creating a VmInstancesValue value, an extra attribute value was detected. "+
					"A VmInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VmInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVmInstancesValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	datacenterAttribute, ok := attributes["datacenter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datacenter is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	datacenterVal, ok := datacenterAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datacenter expected to be basetypes.ObjectValue, was: %T`, datacenterAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nextBillingAtAttribute, ok := attributes["next_billing_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_billing_at is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	nextBillingAtVal, ok := nextBillingAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_billing_at expected to be basetypes.StringValue, was: %T`, nextBillingAtAttribute))
	}

	osImageAttribute, ok := attributes["os_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os_image is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	osImageVal, ok := osImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os_image expected to be basetypes.StringValue, was: %T`, osImageAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	pricePerEpochAttribute, ok := attributes["price_per_epoch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_per_epoch is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	pricePerEpochVal, ok := pricePerEpochAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_per_epoch expected to be basetypes.Int64Value, was: %T`, pricePerEpochAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	reservedBalanceAttribute, ok := attributes["reserved_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_balance is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	reservedBalanceVal, ok := reservedBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_balance expected to be basetypes.StringValue, was: %T`, reservedBalanceAttribute))
	}

	resourcesAttribute, ok := attributes["resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	resourcesVal, ok := resourcesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources expected to be basetypes.ListValue, was: %T`, resourcesAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	totalSpentAttribute, ok := attributes["total_spent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_spent is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	totalSpentVal, ok := totalSpentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_spent expected to be basetypes.StringValue, was: %T`, totalSpentAttribute))
	}

	vmNameAttribute, ok := attributes["vm_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vm_name is missing from object`)

		return NewVmInstancesValueUnknown(), diags
	}

	vmNameVal, ok := vmNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vm_name expected to be basetypes.StringValue, was: %T`, vmNameAttribute))
	}

	if diags.HasError() {
		return NewVmInstancesValueUnknown(), diags
	}

	return VmInstancesValue{
		CreatedAt:       createdAtVal,
		Datacenter:      datacenterVal,
		Id:              idVal,
		NextBillingAt:   nextBillingAtVal,
		OsImage:         osImageVal,
		Ports:           portsVal,
		PricePerEpoch:   pricePerEpochVal,
		PublicIp:        publicIpVal,
		ReservedBalance: reservedBalanceVal,
		Resources:       resourcesVal,
		Status:          statusVal,
		TotalSpent:      totalSpentVal,
		VmName:          vmNameVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVmInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VmInstancesValue {
	object, diags := NewVmInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVmInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VmInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVmInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVmInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVmInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVmInstancesValueMust(VmInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VmInstancesType) ValueType(ctx context.Context) attr.Value {
	return VmInstancesValue{}
}

var _ basetypes.ObjectValuable = VmInstancesValue{}

type VmInstancesValue struct {
	CreatedAt       basetypes.StringValue `tfsdk:"created_at"`
	Datacenter      basetypes.ObjectValue `tfsdk:"datacenter"`
	Id              basetypes.StringValue `tfsdk:"id"`
	NextBillingAt   basetypes.StringValue `tfsdk:"next_billing_at"`
	OsImage         basetypes.StringValue `tfsdk:"os_image"`
	Ports           basetypes.ListValue   `tfsdk:"ports"`
	PricePerEpoch   basetypes.Int64Value  `tfsdk:"price_per_epoch"`
	PublicIp        basetypes.StringValue `tfsdk:"public_ip"`
	ReservedBalance basetypes.StringValue `tfsdk:"reserved_balance"`
	Resources       basetypes.ListValue   `tfsdk:"resources"`
	Status          basetypes.StringValue `tfsdk:"status"`
	TotalSpent      basetypes.StringValue `tfsdk:"total_spent"`
	VmName          basetypes.StringValue `tfsdk:"vm_name"`
	state           attr.ValueState
}

func (v VmInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["datacenter"] = basetypes.ObjectType{
		AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["next_billing_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["os_image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ports"] = basetypes.ListType{
		ElemType: PortsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["price_per_epoch"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["public_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reserved_balance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resources"] = basetypes.ListType{
		ElemType: ResourcesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["total_spent"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vm_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Datacenter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datacenter"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.NextBillingAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_billing_at"] = val

		val, err = v.OsImage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["os_image"] = val

		val, err = v.Ports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports"] = val

		val, err = v.PricePerEpoch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["price_per_epoch"] = val

		val, err = v.PublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_ip"] = val

		val, err = v.ReservedBalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reserved_balance"] = val

		val, err = v.Resources.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resources"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.TotalSpent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_spent"] = val

		val, err = v.VmName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vm_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VmInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VmInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VmInstancesValue) String() string {
	return "VmInstancesValue"
}

func (v VmInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var datacenter basetypes.ObjectValue

	if v.Datacenter.IsNull() {
		datacenter = types.ObjectNull(
			DatacenterValue{}.AttributeTypes(ctx),
		)
	}

	if v.Datacenter.IsUnknown() {
		datacenter = types.ObjectUnknown(
			DatacenterValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Datacenter.IsNull() && !v.Datacenter.IsUnknown() {
		datacenter = types.ObjectValueMust(
			DatacenterValue{}.AttributeTypes(ctx),
			v.Datacenter.Attributes(),
		)
	}

	ports := types.ListValueMust(
		PortsType{
			basetypes.ObjectType{
				AttrTypes: PortsValue{}.AttributeTypes(ctx),
			},
		},
		v.Ports.Elements(),
	)

	if v.Ports.IsNull() {
		ports = types.ListNull(
			PortsType{
				basetypes.ObjectType{
					AttrTypes: PortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ports.IsUnknown() {
		ports = types.ListUnknown(
			PortsType{
				basetypes.ObjectType{
					AttrTypes: PortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	resources := types.ListValueMust(
		ResourcesType{
			basetypes.ObjectType{
				AttrTypes: ResourcesValue{}.AttributeTypes(ctx),
			},
		},
		v.Resources.Elements(),
	)

	if v.Resources.IsNull() {
		resources = types.ListNull(
			ResourcesType{
				basetypes.ObjectType{
					AttrTypes: ResourcesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Resources.IsUnknown() {
		resources = types.ListUnknown(
			ResourcesType{
				basetypes.ObjectType{
					AttrTypes: ResourcesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"datacenter": basetypes.ObjectType{
			AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
		},
		"id":              basetypes.StringType{},
		"next_billing_at": basetypes.StringType{},
		"os_image":        basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: PortsValue{}.Type(ctx),
		},
		"price_per_epoch":  basetypes.Int64Type{},
		"public_ip":        basetypes.StringType{},
		"reserved_balance": basetypes.StringType{},
		"resources": basetypes.ListType{
			ElemType: ResourcesValue{}.Type(ctx),
		},
		"status":      basetypes.StringType{},
		"total_spent": basetypes.StringType{},
		"vm_name":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":       v.CreatedAt,
			"datacenter":       datacenter,
			"id":               v.Id,
			"next_billing_at":  v.NextBillingAt,
			"os_image":         v.OsImage,
			"ports":            ports,
			"price_per_epoch":  v.PricePerEpoch,
			"public_ip":        v.PublicIp,
			"reserved_balance": v.ReservedBalance,
			"resources":        resources,
			"status":           v.Status,
			"total_spent":      v.TotalSpent,
			"vm_name":          v.VmName,
		})

	return objVal, diags
}

func (v VmInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VmInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Datacenter.Equal(other.Datacenter) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.NextBillingAt.Equal(other.NextBillingAt) {
		return false
	}

	if !v.OsImage.Equal(other.OsImage) {
		return false
	}

	if !v.Ports.Equal(other.Ports) {
		return false
	}

	if !v.PricePerEpoch.Equal(other.PricePerEpoch) {
		return false
	}

	if !v.PublicIp.Equal(other.PublicIp) {
		return false
	}

	if !v.ReservedBalance.Equal(other.ReservedBalance) {
		return false
	}

	if !v.Resources.Equal(other.Resources) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.TotalSpent.Equal(other.TotalSpent) {
		return false
	}

	if !v.VmName.Equal(other.VmName) {
		return false
	}

	return true
}

func (v VmInstancesValue) Type(ctx context.Context) attr.Type {
	return VmInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VmInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"datacenter": basetypes.ObjectType{
			AttrTypes: DatacenterValue{}.AttributeTypes(ctx),
		},
		"id":              basetypes.StringType{},
		"next_billing_at": basetypes.StringType{},
		"os_image":        basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: PortsValue{}.Type(ctx),
		},
		"price_per_epoch":  basetypes.Int64Type{},
		"public_ip":        basetypes.StringType{},
		"reserved_balance": basetypes.StringType{},
		"resources": basetypes.ListType{
			ElemType: ResourcesValue{}.Type(ctx),
		},
		"status":      basetypes.StringType{},
		"total_spent": basetypes.StringType{},
		"vm_name":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DatacenterType{}

type DatacenterType struct {
	basetypes.ObjectType
}

func (t DatacenterType) Equal(o attr.Type) bool {
	other, ok := o.(DatacenterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DatacenterType) String() string {
	return "DatacenterType"
}

func (t DatacenterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificationsAttribute, ok := attributes["certifications"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certifications is missing from object`)

		return nil, diags
	}

	certificationsVal, ok := certificationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certifications expected to be basetypes.ListValue, was: %T`, certificationsAttribute))
	}

	cityCodeAttribute, ok := attributes["city_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city_code is missing from object`)

		return nil, diags
	}

	cityCodeVal, ok := cityCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city_code expected to be basetypes.StringValue, was: %T`, cityCodeAttribute))
	}

	cityIndexAttribute, ok := attributes["city_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city_index is missing from object`)

		return nil, diags
	}

	cityIndexVal, ok := cityIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city_index expected to be basetypes.Int64Value, was: %T`, cityIndexAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return nil, diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	tierAttribute, ok := attributes["tier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tier is missing from object`)

		return nil, diags
	}

	tierVal, ok := tierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tier expected to be basetypes.Int64Value, was: %T`, tierAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DatacenterValue{
		Certifications: certificationsVal,
		CityCode:       cityCodeVal,
		CityIndex:      cityIndexVal,
		CountryCode:    countryCodeVal,
		Id:             idVal,
		Tier:           tierVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewDatacenterValueNull() DatacenterValue {
	return DatacenterValue{
		state: attr.ValueStateNull,
	}
}

func NewDatacenterValueUnknown() DatacenterValue {
	return DatacenterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDatacenterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DatacenterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DatacenterValue Attribute Value",
				"While creating a DatacenterValue value, a missing attribute value was detected. "+
					"A DatacenterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatacenterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DatacenterValue Attribute Type",
				"While creating a DatacenterValue value, an invalid attribute value was detected. "+
					"A DatacenterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatacenterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DatacenterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DatacenterValue Attribute Value",
				"While creating a DatacenterValue value, an extra attribute value was detected. "+
					"A DatacenterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DatacenterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDatacenterValueUnknown(), diags
	}

	certificationsAttribute, ok := attributes["certifications"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certifications is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	certificationsVal, ok := certificationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certifications expected to be basetypes.ListValue, was: %T`, certificationsAttribute))
	}

	cityCodeAttribute, ok := attributes["city_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city_code is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	cityCodeVal, ok := cityCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city_code expected to be basetypes.StringValue, was: %T`, cityCodeAttribute))
	}

	cityIndexAttribute, ok := attributes["city_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city_index is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	cityIndexVal, ok := cityIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city_index expected to be basetypes.Int64Value, was: %T`, cityIndexAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	tierAttribute, ok := attributes["tier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tier is missing from object`)

		return NewDatacenterValueUnknown(), diags
	}

	tierVal, ok := tierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tier expected to be basetypes.Int64Value, was: %T`, tierAttribute))
	}

	if diags.HasError() {
		return NewDatacenterValueUnknown(), diags
	}

	return DatacenterValue{
		Certifications: certificationsVal,
		CityCode:       cityCodeVal,
		CityIndex:      cityIndexVal,
		CountryCode:    countryCodeVal,
		Id:             idVal,
		Tier:           tierVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewDatacenterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DatacenterValue {
	object, diags := NewDatacenterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDatacenterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DatacenterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDatacenterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDatacenterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDatacenterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDatacenterValueMust(DatacenterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DatacenterType) ValueType(ctx context.Context) attr.Value {
	return DatacenterValue{}
}

var _ basetypes.ObjectValuable = DatacenterValue{}

type DatacenterValue struct {
	Certifications basetypes.ListValue   `tfsdk:"certifications"`
	CityCode       basetypes.StringValue `tfsdk:"city_code"`
	CityIndex      basetypes.Int64Value  `tfsdk:"city_index"`
	CountryCode    basetypes.StringValue `tfsdk:"country_code"`
	Id             basetypes.StringValue `tfsdk:"id"`
	Tier           basetypes.Int64Value  `tfsdk:"tier"`
	state          attr.ValueState
}

func (v DatacenterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["certifications"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["city_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city_index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["country_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tier"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Certifications.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certifications"] = val

		val, err = v.CityCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city_code"] = val

		val, err = v.CityIndex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city_index"] = val

		val, err = v.CountryCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country_code"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Tier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tier"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DatacenterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DatacenterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DatacenterValue) String() string {
	return "DatacenterValue"
}

func (v DatacenterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var certificationsVal basetypes.ListValue
	switch {
	case v.Certifications.IsUnknown():
		certificationsVal = types.ListUnknown(types.StringType)
	case v.Certifications.IsNull():
		certificationsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		certificationsVal, d = types.ListValue(types.StringType, v.Certifications.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"certifications": basetypes.ListType{
				ElemType: types.StringType,
			},
			"city_code":    basetypes.StringType{},
			"city_index":   basetypes.Int64Type{},
			"country_code": basetypes.StringType{},
			"id":           basetypes.StringType{},
			"tier":         basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"certifications": basetypes.ListType{
			ElemType: types.StringType,
		},
		"city_code":    basetypes.StringType{},
		"city_index":   basetypes.Int64Type{},
		"country_code": basetypes.StringType{},
		"id":           basetypes.StringType{},
		"tier":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certifications": certificationsVal,
			"city_code":      v.CityCode,
			"city_index":     v.CityIndex,
			"country_code":   v.CountryCode,
			"id":             v.Id,
			"tier":           v.Tier,
		})

	return objVal, diags
}

func (v DatacenterValue) Equal(o attr.Value) bool {
	other, ok := o.(DatacenterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certifications.Equal(other.Certifications) {
		return false
	}

	if !v.CityCode.Equal(other.CityCode) {
		return false
	}

	if !v.CityIndex.Equal(other.CityIndex) {
		return false
	}

	if !v.CountryCode.Equal(other.CountryCode) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Tier.Equal(other.Tier) {
		return false
	}

	return true
}

func (v DatacenterValue) Type(ctx context.Context) attr.Type {
	return DatacenterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DatacenterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certifications": basetypes.ListType{
			ElemType: types.StringType,
		},
		"city_code":    basetypes.StringType{},
		"city_index":   basetypes.Int64Type{},
		"country_code": basetypes.StringType{},
		"id":           basetypes.StringType{},
		"tier":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortsType{}

type PortsType struct {
	basetypes.ObjectType
}

func (t PortsType) Equal(o attr.Type) bool {
	other, ok := o.(PortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortsType) String() string {
	return "PortsType"
}

func (t PortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortsValue{
		Port:     portVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPortsValueNull() PortsValue {
	return PortsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortsValueUnknown() PortsValue {
	return PortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortsValue Attribute Value",
				"While creating a PortsValue value, a missing attribute value was detected. "+
					"A PortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortsValue Attribute Type",
				"While creating a PortsValue value, an invalid attribute value was detected. "+
					"A PortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortsValue Attribute Value",
				"While creating a PortsValue value, an extra attribute value was detected. "+
					"A PortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	return PortsValue{
		Port:     portVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortsValue {
	object, diags := NewPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortsValueMust(PortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortsType) ValueType(ctx context.Context) attr.Value {
	return PortsValue{}
}

var _ basetypes.ObjectValuable = PortsValue{}

type PortsValue struct {
	Port     basetypes.Int64Value  `tfsdk:"port"`
	Protocol basetypes.StringValue `tfsdk:"protocol"`
	state    attr.ValueState
}

func (v PortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortsValue) String() string {
	return "PortsValue"
}

func (v PortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"port":     basetypes.Int64Type{},
		"protocol": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port":     v.Port,
			"protocol": v.Protocol,
		})

	return objVal, diags
}

func (v PortsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v PortsValue) Type(ctx context.Context) attr.Type {
	return PortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port":     basetypes.Int64Type{},
		"protocol": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ResourcesType{}

type ResourcesType struct {
	basetypes.ObjectType
}

func (t ResourcesType) Equal(o attr.Type) bool {
	other, ok := o.(ResourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourcesType) String() string {
	return "ResourcesType"
}

func (t ResourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	priceAttribute, ok := attributes["price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price is missing from object`)

		return nil, diags
	}

	priceVal, ok := priceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price expected to be basetypes.StringValue, was: %T`, priceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourcesValue{
		Price:         priceVal,
		ResourcesType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewResourcesValueNull() ResourcesValue {
	return ResourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewResourcesValueUnknown() ResourcesValue {
	return ResourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourcesValue Attribute Value",
				"While creating a ResourcesValue value, a missing attribute value was detected. "+
					"A ResourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourcesValue Attribute Type",
				"While creating a ResourcesValue value, an invalid attribute value was detected. "+
					"A ResourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourcesValue Attribute Value",
				"While creating a ResourcesValue value, an extra attribute value was detected. "+
					"A ResourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourcesValueUnknown(), diags
	}

	priceAttribute, ok := attributes["price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	priceVal, ok := priceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price expected to be basetypes.StringValue, was: %T`, priceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewResourcesValueUnknown(), diags
	}

	return ResourcesValue{
		Price:         priceVal,
		ResourcesType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewResourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourcesValue {
	object, diags := NewResourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourcesValueMust(ResourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourcesType) ValueType(ctx context.Context) attr.Value {
	return ResourcesValue{}
}

var _ basetypes.ObjectValuable = ResourcesValue{}

type ResourcesValue struct {
	Price         basetypes.StringValue `tfsdk:"price"`
	ResourcesType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v ResourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["price"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Price.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["price"] = val

		val, err = v.ResourcesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourcesValue) String() string {
	return "ResourcesValue"
}

func (v ResourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"price": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"price": v.Price,
			"type":  v.ResourcesType,
		})

	return objVal, diags
}

func (v ResourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Price.Equal(other.Price) {
		return false
	}

	if !v.ResourcesType.Equal(other.ResourcesType) {
		return false
	}

	return true
}

func (v ResourcesValue) Type(ctx context.Context) attr.Type {
	return ResourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"price": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}
